# Base Case:
# If the number of rows (numRows) is 0, return an empty list ([]), as there are no rows to generate.
# Recursive Case:
# If the number of rows is 1, return a list with a single sublist containing the number 1 ([1]), as it is the first row of Pascal's Triangle.
# For each row greater than 1, recursively generate the previous row and use it to calculate the current row.
# The current row is generated by adding adjacent elements from the previous row and appending 1 at the beginning and end.
# Repeat the process until the desired number of rows is reached.
# This approach works by breaking down the problem into smaller subproblems. The base case handles the termination condition when there are no rows to generate.

class Solution:
    def generatePascalTriangle(self, numRows):
        if numRows == 0:
            return []

        if numRows == 1:
            return [[1]]
        
        triangle = self.generatePascalTriangle(numRows-1)
        print(f"NR: {numRows} and TR: {triangle}")
        prev_row = triangle[-1]
        curr_row = [1]
        print(f"PR: {prev_row} and CR: {curr_row}")
        for i in range(1, numRows-1):
            sum = prev_row[i-1] + prev_row[i]
            print(f"S: {sum}")
            curr_row.append(sum)
        curr_row.append(1)
        print(f"CR: {curr_row}")
        triangle.append(curr_row)
        return triangle


sol = Solution()
numRows = 5
pascal_triangle = sol.generatePascalTriangle(numRows)
print(f"Pascal's Triangle for {numRows} rows:")
for row in pascal_triangle:
    print(row)
    

# Tc: O(n^2) Sc: O(n^2)